// proto/mesh.proto
// Core service definitions for Echo-System mesh communication

syntax = "proto3";

package echosystem;

option go_package = "./proto";

// ─────────────────────────────────────────────
// TYPES
// ─────────────────────────────────────────────

enum TaskType {
  TEXT        = 0;
  CODE        = 1;
  VISION      = 2;
  SUMMARIZE   = 3;
  EMBED       = 4;
}

enum NodeStatus {
  IDLE        = 0;
  BUSY        = 1;
  OVERLOADED  = 2;
  OFFLINE     = 3;
}

// ─────────────────────────────────────────────
// MESSAGES
// ─────────────────────────────────────────────

message ModelInfo {
  string name        = 1;   // e.g. "codellama", "llava", "mistral"
  TaskType type      = 2;
  float size_gb      = 3;
  bool is_loaded     = 4;   // currently loaded in memory?
}

message HardwareInfo {
  float ram_total_gb = 1;
  float ram_free_gb  = 2;
  bool  has_gpu      = 3;
  float gpu_vram_gb  = 4;
  string arch        = 5;   // "arm64", "amd64"
}

message NodeCapabilities {
  string node_id          = 1;
  string host             = 2;
  int32  port             = 3;
  repeated ModelInfo models = 4;
  HardwareInfo hardware   = 5;
  NodeStatus status       = 6;
  int32  active_tasks     = 7;
  int64  last_seen_unix   = 8;
}

// ─────────────────────────────────────────────
// TASK MESSAGES
// ─────────────────────────────────────────────

message TaskRequest {
  string task_id      = 1;   // UUID generated by client
  TaskType type       = 2;
  string prompt       = 3;
  bytes  image_data   = 4;   // optional — for vision tasks
  string model_hint   = 5;   // optional — request specific model
  TaskOptions options = 6;
}

message TaskOptions {
  float  temperature  = 1;
  int32  max_tokens   = 2;
  bool   stream       = 3;   // stream tokens back?
  int32  timeout_sec  = 4;
}

message TaskChunk {
  string task_id    = 1;
  string token      = 2;   // streamed token
  bool   done       = 3;   // final chunk?
  string routed_to  = 4;   // which node_id handled this
  int64  latency_ms = 5;   // time from routing to first token
}

message TaskResult {
  string task_id    = 1;
  string content    = 2;   // full response (non-streamed)
  string routed_to  = 3;
  int64  latency_ms = 4;
  bool   success    = 5;
  string error      = 6;
}

// ─────────────────────────────────────────────
// PIPELINE MESSAGES
// ─────────────────────────────────────────────

message PipelineStep {
  int32    step_index  = 1;
  TaskType type        = 2;
  string   prompt_template = 3;  // use {{prev_output}} to inject previous step result
  string   model_hint  = 4;
}

message PipelineRequest {
  string pipeline_id        = 1;
  repeated PipelineStep steps = 2;
  string initial_input      = 3;
  bytes  initial_image      = 4;  // optional
}

message PipelineResult {
  string pipeline_id          = 1;
  repeated TaskResult steps   = 2;  // one per step
  string final_output         = 3;
  bool   success              = 4;
  string error                = 5;
}

// ─────────────────────────────────────────────
// HEARTBEAT
// ─────────────────────────────────────────────

message HeartbeatRequest {
  string node_id      = 1;
  NodeStatus status   = 2;
  int32  active_tasks = 3;
  float  ram_free_gb  = 4;
}

message HeartbeatResponse {
  bool   acknowledged = 1;
  int64  server_time  = 2;
}

// ─────────────────────────────────────────────
// SERVICES
// ─────────────────────────────────────────────

// MeshOrchestrator — exposed by the orchestrator node
// Clients and node agents call into this
service MeshOrchestrator {
  // Client → Orchestrator: submit a task
  rpc SubmitTask(TaskRequest) returns (TaskResult);

  // Client → Orchestrator: submit + stream tokens back
  rpc SubmitTaskStream(TaskRequest) returns (stream TaskChunk);

  // Client → Orchestrator: multi-step pipeline
  rpc SubmitPipeline(PipelineRequest) returns (PipelineResult);

  // Dashboard → Orchestrator: get all node states
  rpc GetMeshStatus(Empty) returns (MeshStatus);
}

// NodeAgent — exposed by EACH device running the agent
// Orchestrator calls into this to execute tasks
service NodeAgent {
  // Orchestrator → Node: execute a task
  rpc ExecuteTask(TaskRequest) returns (TaskResult);

  // Orchestrator → Node: execute + stream tokens back
  rpc ExecuteTaskStream(TaskRequest) returns (stream TaskChunk);

  // Orchestrator → Node: register + start heartbeat loop
  rpc Register(NodeCapabilities) returns (RegistrationResponse);

  // Orchestrator → Node: ping
  rpc Heartbeat(HeartbeatRequest) returns (HeartbeatResponse);

  // Orchestrator → Node: ask what models are loaded right now
  rpc GetCapabilities(Empty) returns (NodeCapabilities);
}

// ─────────────────────────────────────────────
// MISC
// ─────────────────────────────────────────────

message Empty {}

message MeshStatus {
  repeated NodeCapabilities nodes = 1;
  int32  total_tasks_today        = 2;
  int32  active_tasks             = 3;
  float  avg_latency_ms           = 4;
}

message RegistrationResponse {
  bool   accepted     = 1;
  string assigned_id  = 2;  // orchestrator may normalize the node_id
  string message      = 3;
}
